package com.monoid.hackernews.ksp.injection

import android.app.Activity
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.processing.SymbolProcessorProvider
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSFile
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.monoid.hackernews.common.core.metro.ActivityGraph
import com.monoid.hackernews.common.core.metro.ActivityKey
import com.monoid.hackernews.common.core.metro.ActivityScope
import com.monoid.hackernews.common.core.metro.ContributesAndroidInjector
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.toClassName
import dev.zacsweers.metro.AppScope
import dev.zacsweers.metro.BindingContainer
import dev.zacsweers.metro.Binds
import dev.zacsweers.metro.ContributesTo
import dev.zacsweers.metro.GraphExtension
import dev.zacsweers.metro.IntoMap
import dev.zacsweers.metro.Provides
import java.io.File
import java.io.OutputStreamWriter

class InjectionKspProcessor(
    environment: SymbolProcessorEnvironment,
) : SymbolProcessor {
    private val codeGenerator = environment.codeGenerator

    private val outputDirectory = run {
        codeGenerator::class.java
            .getDeclaredMethod(
                "extensionToDirectory",
                String::class.java,
            )
            .apply { isAccessible = true }
            .invoke(codeGenerator, "kotlin") as File
    }.parentFile.let { File(it, "screenshotTest") }

    override fun process(resolver: Resolver): List<KSAnnotated> {
        resolver
            .getSymbolsWithAnnotation(checkNotNull(ContributesAndroidInjector::class.qualifiedName))
            .filterIsInstance<KSFunctionDeclaration>()
            .groupBy { it.containingFile }
            .forEach { (ksFile, ksFunctionDeclarations) ->
                val fileSpec = checkNotNull(ksFile).toScreenshotTestFileSpec(ksFunctionDeclarations)
                OutputStreamWriter(
                    codeGenerator.createNewFile(
                        dependencies = Dependencies(false, ksFile),
                        packageName = fileSpec.packageName,
                        fileName = fileSpec.name,
                    ),
                    Charsets.UTF_8,
                ).use(fileSpec::writeTo)
            }
        return emptyList()
    }

    class Factory : SymbolProcessorProvider {
        override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
            return InjectionKspProcessor(environment)
        }
    }
}

private fun KSFile.toScreenshotTestFileSpec(
    ksFunctionDeclarations: List<KSFunctionDeclaration>,
): FileSpec {
    val testClassName = "${fileName.removeSuffix(".kt").removeSuffix(".android")}Injection"
    return FileSpec
        .builder(packageName.asString(), testClassName)
        .indent("    ")
        .addFileComment("Code generated by $PROCESSOR_NAME. Do not edit.")
        .apply {
            ksFunctionDeclarations.forEach { ksFunctionDeclaration ->
                val className =
                    checkNotNull(ksFunctionDeclaration.returnType).resolve().toClassName()
                val graphName = ClassName(packageName, "${className.simpleName}Graph")
                val factoryName = ClassName(packageName, "${graphName.simpleName}.Factory")
                val appBindingsName = ClassName(packageName, "${className.simpleName}AppBindings")
                val createGraphName = "create${className.simpleName}Graph"
                TypeSpec
                    .interfaceBuilder(graphName)
                    .addAnnotation(
                        AnnotationSpec
                            .builder(GraphExtension::class)
                            .addMember("%T::class", ActivityScope::class)
                            .build(),
                    )
                    .addSuperinterface(ActivityGraph::class)
                    .addFunction(
                        FunSpec
                            .builder("bindActivity")
                            .addModifiers(KModifier.ABSTRACT)
                            .addAnnotation(Binds::class)
                            .addParameter(
                                ParameterSpec
                                    .builder(name = "activity", type = className)
                                    .build(),
                            )
                            .returns(Activity::class)
                            .build(),
                    )
                    .addType(
                        TypeSpec
                            .interfaceBuilder("Factory")
                            .addAnnotation(
                                AnnotationSpec
                                    .builder(ContributesTo::class)
                                    .addMember("%T::class", AppScope::class)
                                    .build(),
                            )
                            .addAnnotation(GraphExtension.Factory::class)
                            .apply {
                                addFunction(
                                    FunSpec
                                        .builder(createGraphName)
                                        .addModifiers(KModifier.ABSTRACT)
                                        .returns(graphName)
                                        .build(),
                                )
                            }
                            .build()
                    )
                    .build()
                    .run { addType(this@run) }

                TypeSpec
                    .objectBuilder(appBindingsName)
                    .addAnnotation(
                        AnnotationSpec
                            .builder(ContributesTo::class)
                            .addMember("%T::class", AppScope::class)
                            .build(),
                    )
                    .addAnnotation(BindingContainer::class)
                    .addFunction(
                        FunSpec
                            .builder("provideActivityGraph")
                            .addAnnotation(
                                AnnotationSpec
                                    .builder(ActivityKey::class)
                                    .addMember("%T::class", className)
                                    .build(),
                            )
                            .addAnnotation(IntoMap::class)
                            .addAnnotation(Provides::class)
                            .addParameter("graphFactory", factoryName)
                            .returns(ActivityGraph::class)
                            .addCode(CodeBlock.of("return graphFactory.${createGraphName}()"))
                            .build(),
                    )
                    .build()
                    .run { addType(this@run) }
            }
        }
        .build()
}

private const val PROCESSOR_NAME = "InjectionKspProcessor"
