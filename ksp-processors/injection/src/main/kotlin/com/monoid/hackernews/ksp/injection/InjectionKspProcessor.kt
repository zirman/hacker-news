package com.monoid.hackernews.ksp.injection

import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.processing.SymbolProcessorProvider
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSFile
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.monoid.hackernews.common.core.metro.ActivityGraph
import com.monoid.hackernews.common.core.metro.ActivityKey
import com.monoid.hackernews.common.core.metro.ActivityScope
import com.monoid.hackernews.common.core.metro.ContributesActivityInjector
import com.monoid.hackernews.common.core.metro.ContributesServiceInjector
import com.monoid.hackernews.common.core.metro.ServiceGraph
import com.monoid.hackernews.common.core.metro.ServiceKey
import com.monoid.hackernews.common.core.metro.ServiceScope
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.toClassName
import dev.zacsweers.metro.AppScope
import dev.zacsweers.metro.BindingContainer
import dev.zacsweers.metro.ContributesTo
import dev.zacsweers.metro.GraphExtension
import dev.zacsweers.metro.IntoMap
import dev.zacsweers.metro.Provides
import java.io.OutputStreamWriter
import kotlin.reflect.KClass

class InjectionKspProcessor(
    environment: SymbolProcessorEnvironment,
) : SymbolProcessor {
    private val codeGenerator = environment.codeGenerator

    override fun process(resolver: Resolver): List<KSAnnotated> {
        resolver
            .getSymbolsWithAnnotation(checkNotNull(ContributesActivityInjector::class.qualifiedName))
            .filterIsInstance<KSFunctionDeclaration>()
            .groupBy { it.containingFile }
            .forEach { (ksFile, ksFunctionDeclarations) ->
                val fileSpec = checkNotNull(ksFile).toInjectionFileSpec(
                    ksFunctionDeclarations,
                    scope = ActivityScope::class,
                    graph = ActivityGraph::class,
                    key = ActivityKey::class,
                )
                OutputStreamWriter(
                    codeGenerator.createNewFile(
                        dependencies = Dependencies(false, ksFile),
                        packageName = fileSpec.packageName,
                        fileName = fileSpec.name,
                    ),
                    Charsets.UTF_8,
                ).use(fileSpec::writeTo)
            }
        resolver
            .getSymbolsWithAnnotation(checkNotNull(ContributesServiceInjector::class.qualifiedName))
            .filterIsInstance<KSFunctionDeclaration>()
            .groupBy { it.containingFile }
            .forEach { (ksFile, ksFunctionDeclarations) ->
                val fileSpec = checkNotNull(ksFile).toInjectionFileSpec(
                    ksFunctionDeclarations,
                    scope = ServiceScope::class,
                    graph = ServiceGraph::class,
                    key = ServiceKey::class,
                )
                OutputStreamWriter(
                    codeGenerator.createNewFile(
                        dependencies = Dependencies(false, ksFile),
                        packageName = fileSpec.packageName,
                        fileName = fileSpec.name,
                    ),
                    Charsets.UTF_8,
                ).use(fileSpec::writeTo)
            }
        return emptyList()
    }

    class Factory : SymbolProcessorProvider {
        override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
            return InjectionKspProcessor(environment)
        }
    }
}

private fun KSFile.toInjectionFileSpec(
    ksFunctionDeclarations: List<KSFunctionDeclaration>,
    scope: KClass<*>,
    graph: KClass<*>,
    key: KClass<out Annotation>,
): FileSpec {
    val testClassName = "${fileName.removeSuffix(".kt").removeSuffix(".android")}Injection"
    return FileSpec
        .builder(packageName.asString(), testClassName)
        .indent("    ")
        .addFileComment("Code generated by $PROCESSOR_NAME. Do not edit.")
        .apply {
            ksFunctionDeclarations.forEach { ksFunctionDeclaration ->
                val className =
                    checkNotNull(ksFunctionDeclaration.returnType).resolve().toClassName()
                val graphName = ClassName(packageName, "${className.simpleName}Graph")
                val factoryName = ClassName(packageName, "${graphName.simpleName}.Factory")
                val appBindingsName = ClassName(packageName, "${className.simpleName}AppBindings")
                val createGraphName = "create${className.simpleName}Graph"
                TypeSpec
                    .interfaceBuilder(graphName)
                    .addAnnotation(
                        AnnotationSpec
                            .builder(GraphExtension::class)
                            .addMember("%T::class", scope)
                            .build(),
                    )
                    .addSuperinterface(graph)
                    .addType(
                        TypeSpec
                            .interfaceBuilder("Factory")
                            .addAnnotation(
                                AnnotationSpec
                                    .builder(ContributesTo::class)
                                    .addMember("%T::class", AppScope::class)
                                    .build(),
                            )
                            .addAnnotation(GraphExtension.Factory::class)
                            .apply {
                                addFunction(
                                    FunSpec
                                        .builder(createGraphName)
                                        .addModifiers(KModifier.ABSTRACT)
                                        .returns(graphName)
                                        .build(),
                                )
                            }
                            .build()
                    )
                    .build()
                    .run { addType(this@run) }

                TypeSpec
                    .objectBuilder(appBindingsName)
                    .addAnnotation(
                        AnnotationSpec
                            .builder(ContributesTo::class)
                            .addMember("%T::class", AppScope::class)
                            .build(),
                    )
                    .addAnnotation(BindingContainer::class)
                    .addFunction(
                        FunSpec
                            .builder("provideGraph")
                            .addAnnotation(
                                AnnotationSpec
                                    .builder(key)
                                    .addMember("%T::class", className)
                                    .build(),
                            )
                            .addAnnotation(IntoMap::class)
                            .addAnnotation(Provides::class)
                            .addParameter("graphFactory", factoryName)
                            .returns(graph)
                            .addCode(CodeBlock.of("return graphFactory.${createGraphName}()"))
                            .build(),
                    )
                    .build()
                    .run { addType(this@run) }
            }
        }
        .build()
}

private const val PROCESSOR_NAME = "InjectionKspProcessor"
